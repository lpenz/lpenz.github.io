<?xml version="1.0"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Avulsos by Penz - Articles tagged as linux </title>
        <link>http://www.lpenz.org</link>
        <description>Articles tagged as linux in Avulsos by Penz page.</description>
        <managingEditor>lpenz@lpenz.org (Leandro Lisboa Penz)</managingEditor>
        <webMaster>lpenz@lpenz.org (Leandro Lisboa Penz)</webMaster>
        <docs>http://www.rssboard.org/rss-specification</docs>

        <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
        <lastBuildDate>Sun, 22 May 2022 00:00:00 +0000</lastBuildDate>

        <language>en</language>
        <image>
            <title>Avulsos by Penz - Articles tagged as linux </title>
            <link>http://www.lpenz.org</link>
            <url>http://www.lpenz.org/logo-black.png</url>
        </image>
        <atom:link href="http://www.lpenz.org/feeds/articles.xml" rel="self" type="application/rss+xml"/>



		<item>
			<title>Provisioning a Raspberry Pi using ansible</title>
			<link>http://www.lpenz.org/articles/ansiblerpi</link>
			<guid>http://www.lpenz.org/articles/ansiblerpi</guid>
			<pubDate>Tue, 08 Jan 2019 00:00:00 +0000</pubDate>
			<description><![CDATA[<div class="body" id="body">
<p>
These are my notes on how to get started provisioning Raspbian with
ansible.
</p>

<section>
<h1>Before using ansible</h1>

<p>
We have to get a working Raspbian installation before using ansible on
the device.
</p>

<section>
<h2>Installing Raspbian</h2>

<p>
The first step is downloading and installing Raspbian in the SD card
you're going to use in the Pi. You can find the Raspbian image here:
<a href="https://www.raspberrypi.org/downloads/raspbian/">https://www.raspberrypi.org/downloads/raspbian/</a>. Prefer the "lite"
image, as it allows you to start from a cleaner point.
</p>
<p>
To install the image, use an adapter to plug the SD card into a
computer. You can figure out the <code>/dev/</code> device that got assigned by
using <code>lsblk</code> before and after plugging the card. Let's assume it
got assigned to <code>/dev/sdc</code>, for the sake of illustration. The next
step is writting the Raspbian image to it:
</p>

<pre>
unzip -p *-raspbian-stretch-lite.zip | sudo dd of=/dev/sdc bs=4M oflag=dsync status=progress
</pre>

<p>
You can now insert the card into the Raspberry Pi board.
</p>

</section>
<section>
<h2>Initial Raspbian setup</h2>

<p>
Raspbian comes with a initial user <strong>pi</strong>, password <strong>raspberry</strong>,
that can use sudo freely.  <strong>ssh</strong> is installed, but
disabled. Changing the password and enabling ssh are the next steps,
in a console session that should look like the following:
</p>

<pre>
&gt; raspberrypi login: pi
&gt; Password:
passwd
&gt; Changing password for pi.
&gt; (current) UNIX password:
&gt; Enter new UNIX password:
&gt; Retype new UNIX password:
&gt; passwd: password updated successfully
sudo systemctl enable ssh.service
(...)
</pre>

</section>
<section>
<h2>Alternative initial setup</h2>

<p>
Another way to do the initial image setup is by mounting in your system and
changing the required files before writting it in the SD card. To mount the
image:
</p>

<ul>
<li>Extract it from the zip file:
<p></p>

<pre>
unzip *-raspbian-*-lite.zip
</pre>

<p></p>
</li>
<li>Using <code>losetup</code>, map the file to a loopback device, and list the loopback
  devices to figure out where it was mapped:
<p></p>

<pre>
sudo losetup -f *-raspbian-*-lite.img
sudo losetup -l
&gt; NAME       SIZELIMIT OFFSET AUTOCLEAR RO BACK-FILE             DIO LOG-SEC
&gt; /dev/loop0         0      0         0  0 *-raspbian-*-lite.img   0     512
</pre>

<p></p>
From here on we assume that the file was mapped to <code>/dev/loop0</code>.
<p></p>
</li>
<li>Tell the kernel to make the partitions available at <code>/dev/</code> using
  <code>partx</code>, figure out where they are using <code>lsblk</code>:
<p></p>

<pre>
sudo partx -a /dev/loop0
lsblk /dev/loop0
&gt; NAME      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
&gt; loop0       7:0    0  1.8G  0 loop
&gt; ├─loop0p1 259:0    0 43.8M  0 loop
&gt; └─loop0p2 259:1    0  1.7G  0 loop
</pre>

<p></p>
</li>
<li>Mount the partition in a temporary directory:
<p></p>

<pre>
mkdir rpi
sudo mount /dev/loop0p2 rpi
</pre>

<p></p>
</li>
<li>You can now modify the files in the <code>rpi</code> directory. Use
  <code>openssl passwd -1 &lt;password&gt;</code> to get the string to use in the
  <code>etc/shadow</code> file as the password of the <code>pi</code> user. You can also change
  also change the name of the user, just be careful to change it everywhere
  needed:
  <ul>
  <li><code>/etc/passwd</code>
  </li>
  <li><code>/etc/shadow</code>
  </li>
  <li><code>/etc/subuid</code>
  </li>
  <li><code>/etc/group</code>
  </li>
  <li><code>/etc/gshadow</code>
  </li>
  <li><code>/etc/subgid</code>
  </li>
  <li>And rename <code>/home/pi</code>
  </li>
  </ul>
<p></p>
  To enable ssh, you should create init and systemd links:
<p></p>

<pre>
sudo ln -s /lib/systemd/system/ssh.service rpi/etc/systemd/system/sshd.service
sudo ln -s /lib/systemd/system/ssh.service rpi/etc/systemd/system/multi-user.target.wants/ssh.service
for d in rc2.d rc3.d rc4.d rc5.d; do (cd rpi/etc/$d; sudo ln -sf ../init.d/ssh S01ssh); done
find rpi/etc/rc* -name 'K*ssh' -exec sudo rm {} +
</pre>

<p></p>
  Other, security related things to do:
<p></p>

<pre>
sudo rm rpi/etc/sudoers.d/010_pi-nopasswd
</pre>

<p></p>
  You can also change other things if you want. When you are done, proceed to
  the next item.
<p></p>
</li>
<li>Unmount the partition, remove the temporary directory and unmap the loopback
  device:
<p></p>

<pre>
sudo umount rpi
rmdir rpi
sudo losetup -d /dev/loop0
</pre>

<p></p>
</li>
<li>Write the image to the SD card as before:
<p></p>

<pre>
sudo dd if=*-raspbian-*-lite.img of=/dev/sdc bs=4M oflag=dsync status=progress
</pre>

</li>
</ul>

</section>
</section>
<section>
<h1>Using ansible</h1>

<p>
You can now use ansible from any computer to provision the Pi. I'd
recommend, though, using <em>python3</em> as the interpreter on the Pi, as
it has more modules available - *apt_repository*, for instance, is not
directly usable with the default python2 interpreter.
</p>
<p>
A basic playbook that runs tasks as root looks like the following
(save it as <code>playbook-sudo-rpi.yml</code>):
</p>

<pre>
---
- hosts: all
  become: yes
  become_user: root
  vars:
    ansible_python_interpreter: /usr/bin/python3
  tasks:
    - debug: msg="Ansible running in {{ansible_lsb.id}}!"
</pre>

<p>
Assuming that the playbook as available as <code>playbook.yml</code>, and that
<code>raspberrypi</code> is a name that can be resolved to the device, you can
run the playbook with the following command:
</p>

<pre>
ansible-playbook -i raspberrypi, -u pi playbook-sudo-rpi.yml -K
</pre>

<p>
(you can also replace <code>raspberrypi</code> with the actual IP address of
the device)
</p>

<section>
<h2>Setting up Debian repositories</h2>

<p>
Because Raspbian is based on Debian and upstream Debian has support for the
architecture of the Raspberry Pi B+, you can configure and use upstream Debian
repositories and packages in the Pi. To do that, use the follwing snippet:
</p>

<pre>
(...)
  tasks:
    - name: install apt pinning config
      copy: src=apt-pinning dest=/etc/apt/preferences.d/99pinning owner=root group=root mode=0644
    - name: install Debian apt key
      apt_key: url='https://ftp-master.debian.org/keys/archive-key-9.asc' id='E1CF20DDFFE4B89E802658F1E0B11894F66AEC98' state=present
      notify: apt-update
    - name: install Debian apt repositories
      apt_repository: repo='deb http://ftp.debian.org/debian {{item}} main contrib non-free' state=present
      with_items:
        - stable
        - testing
        - unstable
        - experimental
      notify: apt-update
  handlers:
    - name: apt-update
      apt: update-cache=yes
</pre>

<p>
The <a href="apt-pinning">apt-pinning</a> file should contain something like the following:
</p>

<pre>
Package: *
Pin: release o=Raspberry Pi Foundation
Pin-Priority: 600

Package: *
Pin: release o=Raspbian
Pin-Priority: 600

Package: *
Pin: release a=stable
Pin-Priority: 510

Package: *
Pin: release a=testing
Pin-Priority: 520

Package: *
Pin: release a=unstable
Pin-Priority: 150

Package: *
Pin: release a=experimental
Pin-Priority: 120
</pre>

</section>
</section>
</div>
]]></description>
		</item>


		<item>
			<title>Creating a pmount-compatible encrypted USB drive</title>
			<link>http://www.lpenz.org/articles/cryptusb</link>
			<guid>http://www.lpenz.org/articles/cryptusb</guid>
			<pubDate>Sat, 05 Jun 2021 00:00:00 +0000</pubDate>
			<description><![CDATA[]]></description>
		</item>


		<item>
			<title>Using GPG and signing git commits</title>
			<link>http://www.lpenz.org/articles/gpg</link>
			<guid>http://www.lpenz.org/articles/gpg</guid>
			<pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
			<description><![CDATA[]]></description>
		</item>


		<item>
			<title>Create a debian bootable live USB</title>
			<link>http://www.lpenz.org/articles/liveusb</link>
			<guid>http://www.lpenz.org/articles/liveusb</guid>
			<pubDate>Sun, 04 Oct 2015 00:00:00 +0000</pubDate>
			<description><![CDATA[<div class="body" id="body">
<p>
<strong>Updated 2019-06-25</strong>: use Debian Stretch explicitly (already implied
by kernel version); suggest testing with qemu.
</p>
<p>
We can install a full Linux distribution in a USB drive, and use it to boot a
system. That is called a "live USB," and it can be used for recovery, as a
portable environment, etc.
</p>
<p>
In this article we explain how to install a Debian GNU/Linux OS in a USB drive
as if it was a hard disk. We will use Debian's own <em>debootstrap</em> to populate
the root partition and <em>syslinux</em> as a bootloader (it is simpler than the
standard <em>grub</em>).
</p>
<p>
Obs: to ease copy-and-pasting, we show the commands without prompt, and
prepend <code>&gt;</code> to the output of commands on most examples.
</p>

<section>
<h1>1 Partitioning</h1>

<p>
After inserting the USB drive, it will appear as a block device under <em>/dev</em>,
usually <em>sd[a-z]</em>. Take a note on the device name. We will use <em>/dev/sdc</em>
through the examples.
</p>
<p>
Create two partitions on our USB drive: one with 256MB for the <em>/boot</em> that
will hold the <em>syslinux</em> bootloader and the Linux kernel; and another with all
the rest of the space, that will hold the root filesystem.
</p>
<p>
There are many utilities you can use to partition the USB drive: <em>parted</em>,
<em>fdisk</em>, etc.
</p>
<p>
For example, using fdisk, run it on <em>/dev/sdc</em>:
</p>

<pre>
fdisk /dev/sdc
&gt; Welcome to fdisk (util-linux 2.25.2).
&gt; Changes will remain in memory only, until you decide to write them.
&gt; Be careful before using the write command.
</pre>

<p>
You are left at <em>fdisk</em>'s command prompt. Create the boot partition:
</p>

<pre>
Command (m for help): n
&gt; Partition type
&gt;    p   primary (0 primary, 0 extended, 4 free)
&gt;    e   extended (container for logical partitions)
&gt; Select (default p): p
&gt; Partition number (1-4, default 1): 1
&gt; First sector (2048-31350782, default 2048):
&gt; Last sector, +sectors or +size{K,M,G,T,P} (2048-31350782, default 31350782): +256M
&gt; 
&gt; Created a new partition 1 of type 'Linux' and of size 256 MiB.
</pre>

<p>
Set its type to <em>FAT16</em>:
</p>

<pre>
Command (m for help): t
&gt; Selected partition 1
&gt; Hex code (type L to list all codes): 6
&gt; If you have created or modified any DOS 6.x partitions, please see the fdisk documentation for additional information.
&gt; Changed type of partition 'Linux' to 'FAT16'.
</pre>

<p>
Mark it as <em>active</em>:
</p>

<pre>
Command (m for help): a
&gt; The bootable flag on partition 1 is enabled now.
</pre>

<p>
Create the root partition:
</p>

<pre>
Command (m for help): n
&gt; Partition type
&gt;    p   primary (1 primary, 0 extended, 3 free)
&gt;    e   extended (container for logical partitions)
&gt; Select (default p): p
&gt; Partition number (2-4, default 2): 2
&gt; First sector (526336-31350782, default 526336):
&gt; Last sector, +sectors or +size{K,M,G,T,P} (526336-31350782, default 31350782):
&gt; 
&gt; Created a new partition 2 of type 'Linux' and of size 14.7 GiB.
</pre>

<p>
Check that they were created:
</p>

<pre>
Command (m for help): p
&gt; Disk /dev/sdc: 15 GiB, 16051600896 bytes, 31350783 sectors
&gt; Units: sectors of 1 * 512 = 512 bytes
&gt; Sector size (logical/physical): 512 bytes / 512 bytes
&gt; I/O size (minimum/optimal): 512 bytes / 512 bytes
&gt; Disklabel type: dos
&gt; Disk identifier: 0x13090bb3
&gt; 
&gt; Device     Boot  Start      End  Sectors  Size Id Type
&gt; /dev/sdc1  *      2048   526335   524288  256M  6 FAT16
&gt; /dev/sdc2       526336 31350782 30824447 14.7G 83 Linux
</pre>

<p>
Save and exit:
</p>

<pre>
Command (m for help): w
&gt; The partition table has been altered.
&gt; Calling ioctl() to re-read partition table.
&gt; Syncing disks.
</pre>

<p>
We now have a <em>/dev/sdc1</em> that will be our <em>/boot</em>, and <em>/dev/sdc2</em> that
will be our root file system. Observe that the boot partition has a MS-DOS
type - that is required <em>syslinux</em>.
</p>
<p>
(the instructions above are heavily based on
<a href="http://allskyee.blogspot.com.br/2014/01/using-syslinux-to-boot-debootstraped.html">using-syslinux-to-boot-debootstraped</a>)
</p>

</section>
<section>
<h1>2 Installing the bootloader</h1>

<p>
Create a FAT16 filesystem on the boot device:
</p>

<pre>
mkdosfs -n LINUXBOOT /dev/sdc1
&gt; mkfs.fat 3.0.27 (2014-11-12)
</pre>

<p>
Install <em>syslinux</em> on it:
</p>

<pre>
syslinux /dev/sdc1
</pre>

</section>
<section>
<h1>3 Installing the base system in the root partition</h1>

<p>
Create the filesystem:
</p>

<pre>
mkfs.ext4 /dev/sdc2
&gt; mke2fs 1.42.12 (29-Aug-2014)
&gt; Creating filesystem with 3853055 4k blocks and 964768 inodes
&gt; Filesystem UUID: 68d66fd5-97f2-46ed-aee6-dad6f228a172
&gt; Superblock backups stored on blocks:
&gt;         32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208
&gt; 
&gt; Allocating group tables: done
&gt; Writing inode tables: done
&gt; Creating journal (32768 blocks): done
&gt; Writing superblocks and filesystem accounting information: done
</pre>

<p>
You can use any filesystem here, as long as it is supported by your future
kernel.
</p>
<p>
Mount both partitions and use <em>debootstrap</em> to install the base files on it:
</p>

<pre>
mkdir -p usbroot
mount -t auto /dev/sdc2 usbroot
mkdir -p usbroot/boot
mount -t auto /dev/sdc1 usbroot/boot
debootstrap stretch usbroot http://ftp.debian.org/debian
&gt; I: Retrieving Release.gpg 
&gt; I: Checking Release signature
&gt; I: Valid Release signature (key id 75DDC3C4A499F1A18CB5F3C8CBF8D6FD518E17E1)
&gt; I: Retrieving Packages 
&gt; I: Validating Packages 
&gt; I: Resolving dependencies of required packages...
&gt; I: Resolving dependencies of base packages...
&gt; I: Found additional required dependencies: acl adduser dmsetup insserv libaudit1 libaudit-common libbz2-1.0 libcap2 libcap2-bin libcryptsetup4 libdb5.3 libdebconfclient0 libdevmapper1.02.1 libgcrypt20 libgpg-error0 libkmod2 libncursesw5 libprocps3 libsemanage1 libsemanage-common libslang2 libsystemd0 libudev1 libustr-1.0-1 procps systemd systemd-sysv udev 
&gt; I: Found additional base dependencies: libdns-export100 libffi6 libgmp10 libgnutls-deb0-28 libgnutls-openssl27 libhogweed2 libicu52 libidn11 libirs-export91 libisccfg-export90 libisc-export95 libmnl0 libnetfilter-acct1 libnettle4 libnfnetlink0 libp11-kit0 libpsl0 libtasn1-6 
&gt; I: Checking component main on http://ftp.debian.org/debian...
&gt; I: Retrieving acl 2.2.52-2
&gt; (...)
&gt; I: Configuring libc-bin...
&gt; I: Configuring systemd...
&gt; I: Base system installed successfully.
</pre>

</section>
<section>
<h1>4 On-root configuration</h1>

<p>
We will have to <em>chroot</em> into our root filesystem to configure it further.
</p>
<p>
Mount the boot device and the default ones inside the root mount point:
</p>

<pre>
mount -t devtmpfs dev       usbroot/dev
mount -t devpts   devpts    usbroot/dev/pts
mount -t proc     proc      usbroot/proc
mount -t sysfs    sysfs     usbroot/sys
</pre>

<p>
<em>chroot</em> into root:
</p>

<pre>
chroot usbroot /bin/bash
</pre>

<p>
Set the root user password:
</p>

<pre>
passwd
&gt; Enter new UNIX password:
&gt; Retype new UNIX password:
&gt; passwd: password updated successfully
</pre>

<p>
Install the Linux kernel and other important packages:
</p>

<pre>
apt-get install --no-install-recommends -y linux-image-amd64 syslinux busybox-static
&gt; Reading package lists... Done
&gt; Building dependency tree... Done
&gt; The following extra packages will be installed:
&gt;   initramfs-tools klibc-utils libklibc libuuid-perl linux-base linux-image-4.9.0-9-amd64
&gt; Suggested packages:
&gt;   bash-completion linux-doc-3.16 debian-kernel-handbook grub-pc grub-efi extlinux
&gt; Recommended packages:
&gt;   busybox busybox-initramfs busybox-static firmware-linux-free irqbalance
&gt; The following NEW packages will be installed:
&gt;   initramfs-tools klibc-utils libklibc libuuid-perl linux-base linux-image-4.9.0-9-amd64 linux-image-amd64
&gt; 0 upgraded, 7 newly installed, 0 to remove and 0 not upgraded.
&gt; Need to get 34.1 MB of archives.
&gt; After this operation, 164 MB of additional disk space will be used.
&gt; (...)
&gt; Setting up linux-image-amd64 (3.16+63) ...
&gt; Processing triggers for initramfs-tools (0.120) ...
&gt; ln: failed to create hard link '/boot/initrd.img-4.9.0-9-amd64.dpkg-bak' =&gt; '/boot/initrd.img-4.9.0-9-amd64': Operation not permitted
&gt; update-initramfs: Generating /boot/initrd.img-4.9.0-9-amd64
</pre>

<p>
We now have to set up our mount points in the <em>/etc/fstab</em> of the USB drive,
but if we simply use <em>/dev/sdc*</em> as the devices, we will have trouble mounting
it on other systems with a different number of hard drives. To have stable mount
points, we use the <em>UUID</em> - universal unique identifiers - of the filesystems.
Use <em>blkid</em> to find out the values of your identifiers:
</p>

<pre>
blkid
&gt; (...)
&gt; /dev/sdc1: SEC_TYPE="msdos" UUID="2420-26B1" TYPE="vfat" PARTUUID="13090bb3-01"
&gt; /dev/sdc2: UUID="68d66fd5-97f2-46ed-aee6-dad6f228a172" TYPE="ext4" PARTUUID="13090bb3-02"
</pre>

<p>
In this example, the <em>UUID</em> of the boot filesystem is <code>2420-26B1</code>, and the
<em>UUID</em> of the root filesystem is <code>68d66fd5-97f2-46ed-aee6-dad6f228a172</code>. Use
them to populate <em>/etc/fstab</em>:
</p>

<pre>
echo 'UUID=68d66fd5-97f2-46ed-aee6-dad6f228a172 /     ext4 defaults,noatime 0 0' &gt;  etc/fstab
echo 'UUID=2420-26B1                            /boot vfat defaults         0 0' &gt;&gt; etc/fstab
</pre>

<p>
Figure out the name of the kernel and initrd installed on the boot partition:
</p>

<pre>
ls boot/vmlinuz* boot/initrd*
&gt; boot/initrd.img-4.9.0-9-amd64  boot/vmlinuz-4.9.0-9-amd64
</pre>

<p>
And use them with the <em>UUID</em>s to create the <code>boot/syslinux.cfg</code> file, with
the following contents:
</p>

<pre>
default linux
timeout 1
prompt 1

label linux
    kernel vmlinuz-4.9.0-9-amd64
    append initrd=initrd.img-4.9.0-9-amd64 root=UUID=68d66fd5-97f2-46ed-aee6-dad6f228a172 ro
</pre>

<p>
Finally, write <em>syslinux</em>'s master boot record on the USB drive:
</p>

<pre>
cat /usr/lib/SYSLINUX/mbr.bin &gt; /dev/sdc
</pre>

</section>
<section>
<h1>5 Closing up</h1>

<p>
We are now ready to leave the <em>chroot</em> and umount all devices:
</p>

<pre>
exit
umount usbroot/dev/pts
umount usbroot/dev
umount usbroot/proc
umount usbroot/sys
umount usbroot/boot
umount usbroot
</pre>

<p>
We can test our system using qemu:
</p>

<pre>
qemu-system-x86_64 -m 512 -hda /dev/sdc
</pre>

<p>
We should be able to login as <em>root</em>, with the password we set above.
</p>
<p>
If everything is working as expected, we can now remove the USB drive
and use it to boot any computer.
</p>

</section>
<section>
<h1>References</h1>

<p>
This article is, in fact, basically a rehash of the following references with
the <em>UUID</em> part added.
</p>

<ul>
<li><a href="http://allskyee.blogspot.com.br/2014/01/using-syslinux-to-boot-debootstraped.html">http://allskyee.blogspot.com.br/2014/01/using-syslinux-to-boot-debootstraped.html</a>
</li>
<li><a href="http://quietsche-entchen.de/cgi-bin/wiki.cgi/ariane/BootableUsbStick">http://quietsche-entchen.de/cgi-bin/wiki.cgi/ariane/BootableUsbStick</a>
</li>
</ul>

<p>
I've also created a
<a href="https://gist.github.com/lpenz/e7339a0b309e29698186baee92370104">gist</a>
that's easy to change, with the commands in this article.
</p>
</section>
</div>
]]></description>
		</item>


		<item>
			<title>Creating an encrypted directory-in-a-file</title>
			<link>http://www.lpenz.org/articles/luksfile</link>
			<guid>http://www.lpenz.org/articles/luksfile</guid>
			<pubDate>Sun, 22 Mar 2020 00:00:00 +0000</pubDate>
			<description><![CDATA[]]></description>
		</item>


    </channel>
</rss>
