#!/usr/bin/env python3
"""Create gnupg logs for gpg article"""

import sys
import os
import re
import functools
import subprocess
from contextlib import contextmanager
import pexpect
import argparse
import yaml
from io import StringIO

pjoin = os.path.join


@contextmanager
def chdir(d):
    old = os.getcwd()
    os.chdir(d)
    yield
    os.chdir(old)


class Session(pexpect.spawn):
    def __init__(self, env=None, preproc=None, data=None):
        env_ = {"PS1": "\\$ ", "PS2": "=>"}
        env_.update(env or {})
        pexpect.spawn.__init__(
            self,
            "bash",
            ["--norc"],
            encoding="utf-8",
            timeout=10,
            # echo=False,
            env=env_,
        )
        self.preproc = preproc
        self.data = data
        self._prompt = u"[#$] $"
        self._logfd = None
        self._pending = ""
        self.waitready()
        self.sendwait('export PS1="$ "')
        self.sendwait("stty cols 9999")
        self.sendwait("set -e")

    def log(self, s):
        if self.preproc:
            s = self.preproc(s)
        sys.stdout.write(s)
        if self._logfd:
            self._logfd.write(s)

    def process(self):
        self.log(self._pending)
        self._pending = ""
        m = self.match
        i1, i2 = m.span()
        self.log(m.string[0:i1])
        self._pending += m.string[i1:]

    def waitready(self, prompt=None):
        prompt = prompt or self._prompt
        try:
            self.expect(prompt)
        except pexpect.TIMEOUT:
            print(self._pending)
            raise
        return self.process()

    @contextmanager
    def logging(self, key=None):
        fd = StringIO()
        self._logfd = fd
        yield fd
        self._logfd = None
        if self.data is not None and key:
            self.data[key] = fd.getvalue()
        fd.close()

    @contextmanager
    def prompt(self, prompt):
        oldprompt = self._prompt
        self._prompt = prompt
        yield
        self._prompt = oldprompt

    def sendwait(self, s, prompt=None, invisible=False):
        # ini/end_bold smuggles html <b> through pandoc
        self._pending += "{b}%s{/b}" % s
        pexpect.spawn.send(self, s + "\r")
        if invisible:
            self._pending += "\n"
        else:
            self.expect(re.escape(s) + "\r")
        return self.waitready(prompt=prompt)

    def sendpass(self, s):
        return self.sendwait(s, invisible=True)

    def done(self):
        pexpect.spawn.send(self, "exit\r")
        self.expect(pexpect.EOF)
        self.wait()
        self.close()
        assert self.exitstatus == 0


@contextmanager
def bgprocess(cmd):
    r = subprocess.Popen(
        cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
    )
    try:
        yield
    finally:
        r.kill()
        r.wait()


def logfix(passphrase, s):
    s = re.sub("/tmp/tmp[a-z0-9_]{8}/", "", s)
    s = re.sub(r"\s+\r", "", s)
    return s


def do_main(outputfile):
    data = {}
    passphrase = "mypassphrase"
    p = Session(data=data, preproc=functools.partial(logfix, passphrase))
    p.sendwait("dd if=/dev/zero of=/tmp/sdb bs=1M count=50")
    dev = "/tmp/sdb1"
    p.sendwait("dd if=/dev/zero of=%s bs=1M count=50" % dev)
    with p.logging("fdisk"):
        with p.prompt(": $"):
            p.sendwait("sudo fdisk %s" % dev)
            p.sendwait("n")
            p.sendwait("p")
            p.sendwait("")
            p.sendwait("")
            p.sendwait("")
        p.sendwait("w")
    with p.logging("luksformat"):
        p.sendwait("part=%s" % dev)
        with p.prompt(": $"):
            p.sendwait('sudo cryptsetup luksFormat --label cryptflash "$part"')
            p.sendwait("YES")
            p.sendpass(passphrase)
        p.sendpass(passphrase)
    with p.logging("luksopen"):
        p.sendwait('sudo cryptsetup luksOpen "$part" cryptdev', ": $")
        p.sendpass(passphrase)
    with p.logging("mkfs"):
        p.sendwait("sudo mkfs.udf -l cryptflash /dev/mapper/cryptdev")
    with p.logging("luksclose"):
        p.sendwait("sudo cryptsetup luksClose cryptdev")
    data["luksclose"] = data["luksclose"].split("\n")[0]
    p.done()
    for k in data:
        data[k] = data[k].replace("/tmp/sdb", "/dev/sdb").rstrip()
    data["fdisk"] = data["fdisk"].replace("/dev/sdb1", "/dev/sdb")
    with open(outputfile, "w") as fd:
        yaml.dump(data, fd, indent=4)


def main():
    parser = argparse.ArgumentParser(description="Process some integers.")
    parser.add_argument("outputfile")
    args = parser.parse_args()
    do_main(args.outputfile)


if __name__ == "__main__":
    main()
